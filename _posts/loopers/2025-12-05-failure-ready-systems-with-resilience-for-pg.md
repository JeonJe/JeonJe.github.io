---
title: "외부 시스템이 죽어도 우리는 살아남아야 한다 — Resilience 설계의 본질"
description: "PG 연동을 통해 배운 Resilience의 핵심. Timeout, CircuitBreaker, Fallback이 왜 필요한지, 어떤 기준으로 설정했는지 정리했다."
categories:
  - 루퍼스
tags:
  - Resilience
  - CircuitBreaker
  - Timeout
  - Fallback
  - PG연동
  - 이커머스
series: loopers-ecommerce
series_order: 7
toc: true
toc_sticky: true
#image: /assets/img/thumbnail/resilience-design.jpg
---

## TL;DR

- Resilience = 외부가 죽어도 우리는 살아남는 것.
- Timeout, CircuitBreaker, Fallback은 각각 역할이 다르다.
- 설정값에 정답은 없다. 서비스 특성과 SLO 기준으로 판단하고, 모니터링하며 튜닝한다.

---

## 들어가면서

이커머스 프로젝트에서 PG(결제 대행사) 연동을 구현하게 됐다. 포인트 결제만 있던 시스템에 외부 카드 결제를 붙이는 작업이었다.

구현 자체는 어렵지 않았지만, 한 가지 질문이 머릿속을 떠나지 않았다.

**"PG가 5초 동안 응답을 안 하면 어떻게 되지?"**

외부 시스템은 언젠가 죽는다. 느려지기도 하고, 갑자기 에러를 뱉기도 한다. 그때 우리 시스템은 어떻게 해야 할까?

이 글에서는 Resilience가 왜 필요한지, 어떤 패턴들이 있는지, 그리고 설정값을 정할 때 어떤 기준으로 판단했는지를 정리해봤다.

---

## Resilience가 필요한 이유

### 장애는 전파된다

외부 시스템이 느려지면, 우리 시스템도 느려진다. 단순한 이야기 같지만, 실제로는 이런 흐름이다.

```
PG 응답 지연 → 요청 스레드 점유 → 스레드 풀 고갈 → 다른 API도 응답 불가 → 전체 장애
```

PG 하나가 느려졌을 뿐인데, 상품 조회 API까지 멈춰버릴 수 있다. 외부 장애가 내부로 **전파**되는 것이다.

### Resilience의 본질

Resilience(회복 탄력성)는 이 전파를 막는 것이다. 핵심은 세 가지다.

| 단계 | 설명 | 예시 |
|------|------|------|
| **감지** | 문제를 빨리 알아챈다 | Timeout으로 지연 감지 |
| **격리** | 장애가 번지지 않게 막는다 | CircuitBreaker로 호출 차단 |
| **복구** | 정상으로 돌아올 수 있게 한다 | Fallback으로 대안 제공 |

결국 Resilience는 **"외부가 죽어도 우리는 버티는 것"**이다.

---

## 핵심 패턴 3가지

### 1. Timeout — 기다림의 한계를 정한다

Timeout은 가장 기본적인 방어 장치다. **"느리면 버린다"**는 원칙이다.

```
외부 시스템 타임아웃 → 우리 시스템도 느려짐 ❌
외부 시스템 타임아웃 → 우리는 빠르게 실패 처리 ✅
```

Timeout을 설정하지 않으면, 외부 시스템이 응답할 때까지 무한정 기다린다. 그 동안 스레드는 점유된 채로 놀고 있다.

**Timeout 종류 구분**

| 종류 | 설명 |
|------|------|
| **Connection Timeout** | 서버와 연결을 맺는 데 걸리는 최대 시간 |
| **Read Timeout** | 연결 후 응답을 받는 데 걸리는 최대 시간 |

이 둘을 분리해서 설정해야 상황에 맞는 대응이 가능하다.

### 2. Circuit Breaker — 죽은 놈한테 안 물어본다

Circuit Breaker는 **장애가 감지되면 호출 자체를 차단**하는 패턴이다.

전기 회로의 차단기(breaker)에서 이름을 따왔다. 과부하가 걸리면 회로를 끊어서 화재를 막는 것처럼, 외부 시스템이 장애 상태면 요청을 보내지 않는다.

**상태 전이**

```
CLOSED (정상) → 실패율 증가 → OPEN (차단)
                              ↓
                        일정 시간 후
                              ↓
                        HALF_OPEN (테스트)
                              ↓
                    성공 → CLOSED / 실패 → OPEN
```

OPEN 상태에서는 요청을 보내지 않고 즉시 실패 처리한다. 불필요한 대기 시간을 없애고, 장애 시스템에 부하도 주지 않는다.

**설정 예시**

```yaml
resilience4j:
  circuitbreaker:
    instances:
      pg-client:
        sliding-window-type: TIME_BASED
        sliding-window-size: 30           # 최근 30초 기준
        failure-rate-threshold: 30        # 실패율 30% 이상 → OPEN
        wait-duration-in-open-state: 5s   # OPEN 후 5초 대기
```

### 3. Fallback — 실패해도 사용자 경험을 지킨다

Fallback은 **실패 시 대안을 제공**하는 패턴이다.

예를 들어, 추천 서버가 죽었을 때:
- Fallback 없음 → 흰 화면 ❌
- Fallback 있음 → 미리 준비된 Top 100 상품 ✅

완벽하지 않아도 사용자 경험을 어느 정도 유지할 수 있다.

---

## 결제 시나리오에서 배운 것

결제는 Resilience를 배우기 좋은 예시다. **실패했을 때 비용이 크기 때문**이다.

### "결제 실패 ≠ 결과를 모름"

PG 연동 중 가장 중요한 인사이트는 이것이었다.

```java
// ❌ 안티패턴
throw new PgRequestFailedException("결제 실패");
// 사용자에게 "결제 실패"로 보여줌

// ✅ 올바른 방향
// Payment 상태를 REQUEST_FAILED로 저장
// 사용자에게 "결제 처리 중, 잠시 후 확인해주세요"로 안내
```

Fallback에서 FAILED를 반환하면 안 된다. CircuitBreaker가 열렸다는 건 PG에게 요청이 안 갔거나, 결과를 모르는 상태라는 뜻이다. 성공/실패라는 **결과 상태**에 도달했다고 말할 수 없다.

### 상태 관리의 중요성

결제 상태를 단순히 SUCCESS/FAILED로 나누면 안 된다. **진행 상태와 결과 상태를 구분**해야 한다.

| 상태 | 의미 |
|------|------|
| REQUESTED | PG 요청 전 |
| PENDING | PG 응답 받음, 처리 중 |
| SUCCESS | 결제 성공 (결과) |
| FAILED | 결제 실패 (결과) |
| REQUEST_FAILED | PG 요청 자체 실패 (결과를 모름) |

이렇게 나눠야 콜백이 안 왔을 때 스케줄러로 복구하는 로직을 짤 수 있다.

---

## 끝으로 — 내가 세운 판단 기준

설정값을 정할 때 정답은 없다. 다만, 나는 이런 기준을 세웠다.

### 1. SLO 먼저 정하기

"결제 API는 10초 내 응답"이라는 목표를 먼저 정했다. 이 10초 안에 모든 것이 들어가야 한다.

```
┌─────────────────────────────────────────────────┐
│                    10초 SLA                      │
├─────────────────────────────────────────────────┤
│ 내부 로직 (2초) │     PG 호출 (7초)    │ 여유(1초)│
└─────────────────────────────────────────────────┘
```

### 2. 시간 예산 배분

핵심 공식은 이것이다.

```
Retry × Timeout ≤ SLA
```

예를 들어, SLA가 10초이고 Timeout이 5초라면, Retry는 최대 1회만 가능하다. 이 공식을 거꾸로 적용해서 Timeout과 Retry를 정했다.

### 3. 용도별 전략 분리

모든 외부 시스템에 같은 설정을 적용하면 안 된다.

| 대상 | 마인드셋 | Timeout |
|------|----------|---------|
| **PG** | 사용자 응답 안에서 최대한 구제, 실패하면 안전하게 보류 | 넉넉하게 (10초) |
| **DB** | 진실의 근원. 재시도는 최소, 빨리 실패하고 튜닝/복구로 해결 | 짧게 (3초) |
| **Redis** | 있으면 좋은 가속기. 죽으면 없이도 버텨야 한다 | 매우 짧게 (500ms) |

**설정값에 정답은 없다.** 처음에는 보수적으로 시작하고, 모니터링 데이터를 보면서 튜닝하는 것이 정석이다.

### 4. Timeout — 각 설정의 의미와 선택 근거

| 설정 | 값 | 산출 근거 |
|------|-----|----------|
| connect-timeout | 3초 | TCP 연결은 수십~수백ms. 1초는 너무 민감, 3초면 충분한 버퍼 |
| read-timeout | 10초 | 카카오페이 최소 12초, 토스 초기 30초 권장. 보수적으로 10초 선택 |
| timelimiter | 12초 | read-timeout + 2초. 예비 안전망으로 race condition 방지 |

### 5. CircuitBreaker — 장애 감지와 격리의 세부 설정

**slidingWindowSize — 얼마나 긴 시간을 볼 것인가**

CircuitBreaker가 장애를 판단하려면 "최근 상황"을 봐야 한다. 이 윈도우가 너무 짧으면 순간적인 오류에도 서킷이 열리는 **플래핑(flapping)** 현상이 생긴다. 반대로 너무 길면 실제 장애를 감지하는 데 시간이 걸린다.

나는 30초를 선택했다. TPS 100 기준으로 새벽 저트래픽 시간에도 300건 정도의 샘플이 확보되고, 피크 시간에는 더 많은 데이터로 정확한 판단이 가능하다. 10초는 플래핑 위험이 있고, 60초는 장애 감지가 늦어진다.

**slidingWindowType — 시간 기준인가, 횟수 기준인가**

COUNT_BASED는 "최근 N건"을, TIME_BASED는 "최근 N초"를 본다. 이커머스는 새벽과 피크 시간의 트래픽 차이가 크다. COUNT_BASED를 쓰면 새벽에는 100건이 쌓이는 데 한참 걸리고, 피크에는 순식간에 넘어간다.

TIME_BASED를 선택한 이유다. 30초라는 윈도우가 트래픽에 관계없이 일정하게 유지되므로 판단 기준이 흔들리지 않는다.

**failure-rate-threshold — 몇 퍼센트 실패면 장애인가**

실패율 임계치는 "언제 서킷을 열 것인가"를 결정한다. 너무 낮으면 일시적 오류에도 서킷이 열리고, 너무 높으면 실제 장애 상황에서도 요청을 계속 보낸다.

30%를 선택했다. 30초 윈도우에서 300건 중 90건이 실패한다면, 3건 중 1건이 실패하는 셈이다. 이 정도면 "뭔가 심각하게 잘못됐다"고 판단해도 된다. 10%는 너무 민감하고, 50%는 이미 사용자 절반이 피해를 본 후다.

**slow-call-duration — 느린 호출의 기준**

Timeout까지 가지 않았지만 "비정상적으로 느린" 호출도 장애의 전조일 수 있다. 이 설정은 그 기준선이다.

6초를 선택했다. 결제 API의 p99 응답 시간(5초)에 20% 버퍼를 더한 값이다. 중요한 점은 **slow-call-duration이 timelimiter(12초)보다 작아야 한다**는 것이다. 그래야 타임아웃 전에 "느려지고 있다"는 신호를 잡을 수 있다.

**wait-duration-in-open-state — 서킷이 열린 후 얼마나 기다릴 것인가**

서킷이 OPEN 상태가 되면 요청을 차단한다. 하지만 언젠가는 외부 시스템이 복구됐는지 확인해야 한다. 이 설정이 그 대기 시간이다.

5초를 선택했다. 30초 윈도우 내에서 최대 6번의 복구 시도가 가능하다. 1초는 아직 복구 중인 PG에 부하를 주고, 10초는 이미 복구됐는데도 한참을 기다리게 된다.

---

## 참고

- [Resilience4j - CircuitBreaker](https://resilience4j.readme.io/docs/circuitbreaker)
- [배민 테크 블로그 - PG 장애 대응](https://techblog.woowahan.com/15236/)
- [올리브영 테크 블로그 - CircuitBreaker](https://oliveyoung.tech/2023-08-31/circuitbreaker-inventory-squad/)