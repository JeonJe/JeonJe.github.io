---
title: "이커머스에서 상품 조회 캐시 전략 선택하기 — 키 설계부터 읽기/쓰기/무효화 전략까지"
description: "상품 목록, 상품 상세, 브랜드 조회에 각각 다른 캐시 전략을 적용한 과정. 데이터 특성을 고려한 캐시를 적용해 p99 300ms 달성률 57%에서 93%로, RPS 103에서 117로 13% 향상한 경험을 담았습니다."
categories:
  - 루퍼스
tags:
  - 캐시
  - Redis
  - 성능개선
  - 이커머스
series: loopers-ecommerce
series_order: 6
toc: true
toc_sticky: true
image: /assets/img/thumbnail/ecommerce-cache-strategy-selection.jpg
---

## TL;DR

- 데이터 특성(변경 빈도, 무효화 복잡도)에 따라 TTL과 무효화 전략을 다르게 가져갔다.
- 캐시 적용 API는 p99 300ms 달성률 57% → 93%, 전체 RPS 103 → 117(13%) 향상.

---

## 들어가면서

이커머스 프로젝트를 하면서 상품 목록 조회, 상품 상세 조회 등 읽기 성능 개선이 필요해졌다. 막상 캐시를 적용하려니 고민이 생겼다.

**"어떤 데이터를 캐시할까? 캐시 키 이름은? 데이터가 바뀌면 캐시는 어떻게?"**

이번 글에서는 SLO 기준을 정하고, 테스트 데이터를 만든 뒤, 캐시를 적용하면서 고민했던 과정을 정리해봤다.
특히 **캐시 전략을 선택할 때 어떤 기준으로 판단했는지**에 집중했다.

---

## 캐시 전략 개요

**읽기 전략, 쓰기 전략, 무효화 전략** 세 가지를 조합해서 결정해야 한다.

### 읽기 전략

| 전략 | 동작 방식 | 고려할 점 |
|------|----------|----------|
| **Cache-Aside** | 앱이 캐시 확인 → miss면 DB 조회 → 캐시 저장 | 구현이 단순, 읽기 많은 워크로드에 적합 |
| **Read-Through** | 캐시가 DB 조회 대행 | 캐시 인프라 의존도 높음 |
| **Refresh-Ahead** | TTL 만료 전 백그라운드 갱신 | 핫 데이터에 유리, 구현 복잡도 증가 |

### 쓰기 전략

| 전략 | 동작 방식 | 고려할 점 |
|------|----------|----------|
| **Write-Through** | DB + 캐시 동시 저장 | 일관성 보장, 쓰기 지연 증가 |
| **Write-Behind** | 캐시만 저장 → 나중에 DB 반영 | 쓰기 성능 최고, 데이터 유실 위험 |
| **Write-Around** | DB만 저장, 캐시 무시 | 캐시 오염 방지, 다음 읽기 시 miss |

### 무효화 전략

| 전략 | 동작 방식 | 고려할 점 |
|------|----------|----------|
| **TTL Only** | 시간 지나면 자동 만료 | 구현 단순, 지연 허용 시 적합 |
| **Evict** | 변경 시 캐시 삭제 → 다음 요청이 DB 조회 | 구현 단순, 동시성 안전 |
| **Update** | 변경 시 캐시 덮어쓰기 | miss 없이 즉시 반영, 동시성 문제 주의 |

이번에 브랜드 조회, 상품 상세/목록 조회에 캐시를 적용하면서 이 세 가지 전략을 조합해 선택했다.

---

## 테스트 환경

성능 측정을 위한 테스트 데이터를 준비했다.

### 데이터 규모

| 항목 | 값 | 설계 근거 |
|------|-----|-----------|
| 상품 | 50만 건 | 대용량 조회 시 인덱스 유무 차이를 명확히 측정 |
| 브랜드 | 10개 (각 5만 건) | 균등 분배로 동일 조건에서 비교 가능 |
| 좋아요 | 약 565만 건 | 핫키 분포로 정렬 인덱스 효과 측정 |
| 유저 | 1만 명 | - |
| 주문 | 5만 건 | 유저당 평균 5개 |

### 좋아요 분포: 극단적 쏠림

| 구간 | 상품 수 | 좋아요 수 | 비율 |
|------|---------|-----------|------|
| 상위 1% | 5천 개 | 각 1천 개 → 500만 개 | **88%** |
| 상위 1~10% | 4.5만 개 | 각 10개 → 45만 개 | 8% |
| 상위 10~30% | 10만 개 | 각 2개 → 20만 개 | 4% |
| 하위 70% | 35만 개 | 0개 | 0% |

실제 서비스에서 인기 상품에 좋아요가 몰리는 현상을 재현하고 싶었다.
상위 1%가 전체 좋아요의 88%를 차지하는 **극단적 핫키** 분포다.

### SLO 기준

| 지표 | 목표 |
|------|------|
| p99 응답 시간 | 300ms 이내 |
| RPS | 100 이상 |
| 에러율 | 1% 미만 |

이 중 **p99와 RPS**를 핵심 지표로 봤다.
- **p99**: 평균이 빨라도 일부 요청이 느리면 사용자 경험이 나빠진다.
- **RPS**: 처리량이 낮으면 트래픽 증가 시 병목이 된다.

---

## 상품/브랜드별 캐시 전략 선택과 이유

### 브랜드 단건

브랜드 정보는 거의 변하지 않다고 판단하여 TTL을 1일로 길게 잡고, 변경 시에만 캐시를 삭제하는 방식을 선택했다.

- **읽기 (Cache-Aside)**: 캐시 miss 시 DB 조회 후 캐시에 저장한다.
- **쓰기 (Write-Around)**: DB만 저장한다. 비동기적으로 DB에 저장하거나, DB와 캐시에 동시에 저장할 정도로 일관성이 중요하지 않다고 판단했다.
- **무효화 (Evict + TTL)**: 변경 시 캐시를 삭제하고, TTL은 1일로 길게 잡았다. 변경이 적으니 히트율을 최대화할 수 있다.
- **키**: `brand:v1:{id}` — 버전을 포함해서 스키마 변경 시 대응할 수 있게 했다.
- **캐시 레이어**: Repository에서 캐싱한다. 브랜드는 여러 상품에서 참조되므로 재사용성이 높다.

### 상품 단건

상품은 브랜드보다 민감하다. 재고와 가격이 포함되어 있어서 변경이 많은 데이터다.

- **읽기 (Cache-Aside)**: 캐시 miss 시 DB 조회 후 캐시에 저장한다. 재고라는 중요한 데이터를 갖고 있어서 캐시 인프라 의존도를 낮추고, miss 시 DB에서 정확한 값을 가져오는 방식을 택했다.
- **쓰기 (Write-Around)**: DB만 저장한다. 브랜드와 마찬가지로 비동기 저장이나 동시 저장이 필요할 만큼 일관성이 중요하지 않다고 판단했다.
- **무효화 (Evict + TTL)**: 변경 시 캐시를 삭제하고, 변경이 많을 것으로 판단해 브랜드보다 훨씬 짧은 TTL 5분을 사용했다.
- **키**: `product:v1:{id}` — 버전을 포함해서 스키마 변경 시 대응할 수 있게 했다.
- **캐시 레이어**: Repository에서 캐싱한다. 상품 상세, 목록 등 여러 곳에서 참조되므로 재사용성이 높다.

### 상품 목록

목록 캐시가 가장 까다로웠다. 조건 조합이 폭발하기 때문이다.

- **읽기 (Cache-Aside)**: 캐시 miss 시 DB 조회 후 캐시에 저장한다.
- **무효화 (TTL Only)**: Evict 대신 TTL Only를 선택했다. 상품 하나가 변경되면 상품 상세, 브랜드 목록, 전체 목록 등 여러 캐시를 삭제해야 하는데, 재고 변경이 빈번하면 히트율이 급락한다. 그래서 명시적 무효화 없이 1분 TTL로 자연 갱신되게 했다.
- **키**: `product:list:v1:{brandId}`
  - `product:list`: 네임스페이스. 역할별로 분리해서 충돌 방지.
  - `v1`: 버전. 스키마 변경 시 과거 캐시와 강제 분리.
  - `{brandId}`: 브랜드 필터가 있으면 해당 값, 없으면 null.
  - 조건 조합이 많아서 전부 캐시하면 무효화가 복잡해지므로, 비회원 + 최신순 + 1페이지만 캐시한다.
- **캐시 레이어**: Facade에서 캐싱한다. 목록은 여러 조건이 조합된 결과이므로 Repository보다 상위 레이어에서 처리한다.

### 적용된 캐시 전략 요약

| 대상 | 읽기 | 쓰기 | 무효화 | TTL | 키 | 캐시 레이어 |
|------|------|------|--------|-----|-----|-------------|
| 브랜드 | Cache-Aside | Write-Around | Evict | 1일 | `brand:v1:{id}` | Repository |
| 상품 단건 | Cache-Aside | Write-Around | Evict | 5분 | `product:v1:{id}` | Repository |
| 상품 목록 | Cache-Aside | - | TTL Only | 1분 | `product:list:v1:{brandId}` | Facade |

### 고려했지만 적용하지 않은 것

TTL Only를 쓰면 캐시 스탬피드 문제가 생길 수 있다. 만료 시점에 요청이 몰리면서 DB 중복 조회와 캐시 중복 쓰기가 발생한다. 선계산 (Early Recompute)이나 TTL 지터(TTL Jitter) 같은 해결책이 있지만, 지금은 불필요하다고 판단해 적용하지 않았다.

---

## 성능 개선 결과

### 캐시 적용 API (p99 300ms 달성률)

캐시가 적용된 API만 따로 보면 효과가 명확하다.

| API | 미적용 | 적용 후 | 개선 |
|-----|--------|---------|------|
| 주문 목록 | 57% | **93%** | +36%p |
| 좋아요 목록 | 58% | **90%** | +32%p |
| 브랜드 필터 | 39% | **63%** | +24%p |

캐시가 적용된 구간에서는 **90% 이상의 요청이 300ms 이내**에 응답한다.

### 전체 시나리오

캐시가 적용되지 않은 API(인기순, 가격순 등)도 포함한 전체 응답 속도다. 캐시 미적용 API가 느려서 전체 수치는 덜 좋아 보인다.

| 단계 | p99 | avg | RPS |
|------|-----|-----|-----|
| 미적용 | 1.32s | 463ms | 103 |
| 인덱스만 | 1.41s | 362ms | 111 |
| 인덱스 + 캐시 | 951ms | 305ms | 117 |

- **p99**: 인덱스만으로는 개선되지 않고, 캐시를 추가해야 28% 개선된다.
- **avg**: 인덱스로 22%, 캐시 추가로 총 34% 개선.
- **RPS**: 인덱스로 8%, 캐시 추가로 총 13% 향상.

---

## 끝으로

캐시 전략에는 정답이 없어서, 나만의 기준을 찾는 게 어려웠다. 이번에 데이터 특성에 따라 읽기, 쓰기, 무효화 전략의 트레이드오프를 비교하는 연습을 해봤다.

실무에서도 병원 통계 AI 분석 결과, 혈압 분석 결과 등 캐싱할 데이터가 늘어나고 있다. 이번 고민을 바탕으로 기존 캐시 전략도 점검하고, 새로운 대상에도 적절한 전략을 세워봐야겠다.

