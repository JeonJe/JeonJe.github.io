---
title: "실무에서 배운 테스트 코드 — 단위 테스트와 통합 테스트 제대로 이해하기"
description: "테스트 없이 개발하던 환경에서 1년간 단위 테스트와 통합 테스트를 배우고 적용하며 얻은 인사이트. 좋은 테스트 4대 요소, 단위/통합 테스트의 차이, 테스트 더블 활용법까지 실무 경험을 담았습니다."
categories:
  - 테스트
  - 개발방법론
tags:
  - 테스트
  - 단위테스트
  - 통합테스트
  - TDD
  - 클린코드
toc: true
toc_sticky: true
# image: /assets/img/thumbnail/testing-guide.png
---

## TL;DR
테스트의 중요성과 1년간 **레거시 코드를 테스트 가능한 구조로 개선**하며 직접 경험하고 얻은 인사이트를 정리했습니다.

## 들어가며
약 1년 전만 해도 회사 코드는 서비스 레이어에 **비즈니스 로직이 뒤섞여** 있어,
수정한 코드를 배포한 뒤에는 항상 "버그가 발생하지 않을까?"라는 걱정이 있었다.

지난 1년 동안 인프런의 테스트 강의와 외부 **TDD & 클린코드 교육** 과정을 들으며 레거시 코드를 하나씩 개선해 나갔다.
이제는 테스트에 꽤 익숙해졌다고 생각했지만, 최근 다른 개발자분들과 이야기를 나누면서 **단위 테스트와 통합 테스트**에 대해 여전히 헷갈리고 있었다는 걸 깨달았다.

이번 글은 **"나처럼 테스트를 막 배우기 시작했거나, 단위/통합 테스트의 차이가 헷갈리는 개발자"**를 위해,
**왜 테스트를 해야 하는지**, **좋은 테스트는 무엇인지**, **단위 테스트와 통합 테스트는 어떻게 다른지**를 1년간의 경험으로 정리해 보려고 한다.

---

## 테스트 없이 코딩하던 시절

아마 한 번쯤 이런 경험이 있을 거다.
코드를 수정하고 배포했는데, **전혀 예상하지 못한 곳에서 버그가 터지는** 경우.
그럴 땐 사용자 경험이 나빠지고, QA나 동료 개발자까지 문제를 함께 추적해야 한다.
결국 **한 줄 수정이 하루치 업무를 잡아먹게** 된다.

테스트가 없으면 이런 일이 반복된다.
버그를 재현하기 어렵고, 고쳐도 비슷한 문제가 다시 생긴다.
하지만 **테스트가 있다면** 수정 후에도 **심리적인 안정감**이 생긴다.
**"이 부분은 깨지지 않았구나"** 를 눈으로 확인할 수 있기 때문이다.

무엇보다 테스트 코드는 **단순한 검증 도구가 아니다**.
**서비스의 비즈니스 규칙을 설명하는 문서**이기도 하다.
테스트를 작성하면서 스스로 **도메인을 더 깊이 이해**하게 되고,
동료 개발자에게도 **"이 서비스는 어떤 규칙으로 동작하는가"** 를 명확히 보여줄 수 있다.

---

## 좋은 테스트를 만들어가는 과정

처음엔 단순히 "테스트 성공했네? 끝!"이라고 생각했다.
하지만 테스트가 점점 많아지고 유지보수가 늘어나면서, **좋은 테스트와 나쁜 테스트의 차이**를 실감했다.

### 테스트하기 어려운 코드 vs 테스트하기 쉬운 코드

어떤 코드가 테스트하기 어려운지, 예시로 확인해보자.

**Before - 테스트하기 어려운 서비스**
```java
// 비즈니스 로직이 서비스에 집중되어 있음
public void deleteQuestion(long questionId) {
    Question question = repository.findById(questionId); // DB 의존

    if (!question.isOwner(user)) {  // 권한 검증
        throw new CannotDeleteException();
    }

    for (Answer answer : question.getAnswers()) { // 비즈니스 로직
        if (!answer.isOwner(user)) {
            throw new CannotDeleteException();
        }
    }
    // ... 삭제 처리
}
```

**문제점**:
- DB 조회, 권한 검증, 비즈니스 로직이 모두 섞여 있음
- **외부 의존성(DB) 없이는 테스트 불가능**
- 로직만 검증하고 싶어도 Repository를 Mock 해야 함

**After - 테스트하기 쉬운 구조**
```java
// 서비스는 흐름 제어만
public void deleteQuestion(long questionId) {
    Question question = repository.findById(questionId);
    question.delete(user); // 도메인 객체에 위임
    saveDeleteHistory(question);
}

// Question 도메인 객체가 비즈니스 로직 담당
public void delete(User user) {
    if (isNotOwner(user)) {
        throw new CannotDeleteException();
    }
    answers.validateOwner(user); // 일급 컬렉션 활용
    this.deleted = true;
}
```

**개선 효과**:
- 도메인 객체(`Question`)는 **DB 없이 단위 테스트** 가능
- 서비스는 **Mock을 활용한 통합 테스트** 가능
- 비즈니스 로직과 인프라 계층이 분리됨

이 변화를 그림으로 표현하면 다음과 같다:

![레거시 서비스에서 Thin Service로의 변화](/assets/img/2025-10-31-practical-testing-guide-unit-vs-integration/mermaid.png)

> 💡 **더 자세한 리팩토링 과정**은 [서비스 계층 다이어트: Thin Service로 개선하기](https://jeonje.github.io/posts/geultto-learning-management-system-with-tdd-and-clean-code-1/)에서 확인하실 수 있습니다.

### 읽기 어렵고 이해하기 힘든 테스트는 결국 유지보수를 힘들게 한다
- 테스트는 **간단하고 명확히** 작성하자
- 프로덕션 코드와 달리 테스트 의도를 드러낼 수 있는 **중복은 허용해도** 괜찮다고 느꼈다.
- `@ParameterizedTest`, `@DisplayName`, 의미 있는 변수명 등을 활용하여 **테스트의 목적**을 분명히 표현하려고 한다.

### 단순히 "잘 동작한다"가 아니라 "이런 상황에서도 잘 동작할까?"를 검증하자
- 특히 **경계값**이나 **예외 상황**을 다루는 테스트가 진짜 힘을 발휘한다.
- 복잡한 비즈니스 로직에 테스트를 추가할 때마다 "이거 없었으면 큰일 날 뻔했다"는 생각을 자주 했다.

### 테스트는 항상 성공해야 한다
- 실행할 때마다 값이 달라지면 테스트를 **신뢰할 수 없다**.
- `LocalDateTime.now()`나 `Random` 같은 값은 테스트 대상 바깥으로 빼서 **주입(Injection)** 해야 한다.
- 관련 내용은 [테스트는 어떻게 좋은 코드를 만드는가 (feat. 험블 객체 패턴)](https://d2.naver.com/helloworld/9921217)에 잘 설명되어 있다.

이런 개인적인 기준 외에도, 도서 **『단위 테스트(Unit Testing)』** 에서는 아래의 네 가지 기준으로 좋은 테스트를 정리하고 있다.

1. **회귀 방지(Regression Prevention)** — 기존 기능이 망가지지 않도록 지켜준다.
2. **리팩터링 내성(Refactoring Tolerance)** — 코드를 고쳐도 테스트가 깨지지 않는다.
3. **빠른 피드백(Fast Feedback)** — 테스트가 빨라야 자주 돌릴 수 있다.
4. **유지보수성(Maintainability)** — 명확하고 직관적이어야 한다.

---

## 단위 테스트와 통합 테스트, 1년간의 오해

먼저 **단위 테스트**와 **통합 테스트**의 정의부터 살펴보자.

### **단위 테스트(Unit Test)**
- 하나의 **코드 단위**(클래스, 메서드 등)가 올바르게 동작하는지를 검증하는 테스트다.
- 외부 시스템(DB, 네트워크 등)에 의존하지 않고, 필요한 부분은 **Mock, Stub** 등으로 대체한다.
- **빠르고 독립적**으로 실행되며, 로직 자체의 정확성을 보장한다.

### **통합 테스트(Integration Test)**
- **여러 모듈이나 계층이 함께** 동작할 때 올바르게 작동하는지를 검증하는 테스트다.
- 실제 데이터베이스, 외부 API 등 **외부 의존성과 함께** 시스템 전체의 흐름과 결과를 검증한다.
- 단위 테스트보다 느리지만, **현실적인 신뢰도**를 확보할 수 있다.

#### 단위 테스트와 통합 테스트의 잘못된 오해
최근까지 단위 테스트와 통합 테스트의 정의를 잘못 이해하고 있었다.
오랫동안 나는 **단위 테스트 = 목킹 없이 객체 하나만 테스트**라고 생각했다.
그래서 서비스 레이어에서 레포지토리를 목킹하면 "그건 통합 테스트겠지"라고 여겼다.
**잘못된 생각이었다. 단위 테스트이다.**

단위 테스트는 테스트 대상의 로직이 **'올바르게 동작하는지'에 집중**해 검증하는 테스트다.
즉, 서비스 레이어에서 특정 비즈니스 로직 확인에 집중하기 위해 레포지토리 레이어나 다른 객체의 의존성을 **목킹(Mock)** 한다면,
그것은 **단위 테스트로 봐야 한다**.

반대로, **목킹 없이 실제 의존성과 함께** 실행해 시스템이 제대로 작동하는지 확인한다면, 그것이 **통합 테스트**다.

---

단위 테스트와 통합 테스트를 **표로 비교**해보자.

### **단위 테스트 vs 통합 테스트 비교**

| 구분 | 단위 테스트 | 통합 테스트 |
| ----- | -------------- | -------------------------- |
| 목적 | 개별 로직 검증 | 모듈/시스템 연동 검증 |
| 범위 | 작음 | 큼 |
| 속도 | 빠름 | 느림 |
| 의존성 | 없음 (Mock 사용) | 실제 연동 |
| 실패 원인 | 코드 로직 문제 | 설정, 연결, 연동 문제 |
| 예시 | CalculatorTest | UserServiceIntegrationTest |

**좋은 테스트 4대 요소** 관점에서 비교해보면 아래와 같다.

| 테스트 유형 | 회귀 방지 | 리팩터링 내성 | 빠른 피드백 | 유지보수성 |
|--------------|------------|----------------|---------------|---------------|
| 단위 테스트 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 통합 테스트 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |

---

## 통합 테스트에 눈을 뜨다

테스트 코드를 작성하기 위해 서비스 레이어의 **비즈니스 로직을 객체로 분리**하며, 서비스는 **흐름 제어**에 집중하는 구조로 바꿔 나갔다.
덕분에 단위 테스트만으로도 코드의 안정성을 충분히 확인할 수 있었다.

그런데 멘토링에서 **"통합 테스트를 더 많이 작성해보자"**는 조언을 들었다.
그 한마디가, 내가 쌓아온 테스트 습관에 새로운 시각을 던져줬다.

통합 테스트는 단위 테스트보다 작성이 복잡하고, 실행도 느리며, 유지보수 비용도 크다.
그래서 그동안은 **빠른 피드백**이 가능한 단위 테스트에 의존해왔다.

하지만 통합 테스트는 **단위 테스트로는 검증할 수 없는 모듈 간 상호작용**을 다룬다.
실제 데이터베이스나 외부 API와 연결된 상태에서 실행하기 때문에, **현실적인 신뢰성 테스트**를 할 수 있다.
단위 테스트가 코드의 **'안정성'**을 보장한다면, 통합 테스트는 시스템 전체의 **'신뢰도'**를 높여준다.

최근엔 **AI를 활용해** 테스트 코드를 작성하면서, 통합 테스트를 작성하는 부담도 많이 줄었다.
물론 여전히 단위 테스트보다 느리지만, **배포 후 버그를 잡는 비용**에 비하면 훨씬 효율적이다.

---

## 테스트를 도와주는 친구들, 테스트 더블

앞서 단위 테스트를 설명하면서 **목킹(Mock)** 이라는 단어를 여러 번 언급했다.
테스트를 하다 보면, **실제 객체 대신 가짜 객체**가 필요할 때가 있다.
이런 대체 객체들을 **테스트 더블(Test Double)** 이라고 부른다.
말 그대로, 영화 촬영에서 진짜 배우 대신 등장하는 **대역(double)** 같은 존재다.

| 종류 | 역할 | 비유 |
| --------- | -------------------------- | ----------------------------- |
| **Dummy** | 단순히 자리를 채운다. 로직에는 쓰이지 않는다. | 배우 대신 조명 테스트용으로 세워둔 **인형** |
| **Fake** | 간단한 구현체로 실제 동작을 흉내낸다. | 진짜 배우 대신 대충 리허설만 하는 **대역 배우** |
| **Stub** | 미리 정해둔 값을 돌려준다. | "이 질문엔 이 대답만 한다"는 **대본 배우** |
| **Spy** | Stub처럼 동작하지만 호출 기록을 남긴다. | 누가 몇 번 불렀는지 기록하는 **감시자** |
| **Mock** | 호출 자체를 검증한다. | 대사 타이밍과 동작을 체크하는 **리허설 감독** |

코드에서는 아래와 같이 사용한다.

```java
// 📌 Stub 예시 - "미리 정해둔 값 반환"
@Test
void 사용자_조회_성공() {
    // Given: Repository가 특정 ID에 대해 항상 홍길동을 반환하도록 설정
    when(userRepository.findById(1L))
        .thenReturn(Optional.of(new User("홍길동")));

    // When: 서비스 호출
    User user = userService.getUser(1L);

    // Then: 로직 검증 (호출 여부는 검증 안 함)
    assertThat(user.getName()).isEqualTo("홍길동");
}

// 📌 Mock 예시 - "호출 자체를 검증"
@Test
void 주문_생성_시_이메일_발송() {
    // Given
    User user = new User("hong@test.com");
    Product product = new Product("책");

    // When
    orderService.createOrder(user, product);

    // Then: 메일이 정확히 1번 발송되었는지 검증
    verify(emailService, times(1))
        .sendOrderConfirmation("hong@test.com");
}

// 📌 Fake 예시 - "간단한 구현체"
class FakeUserRepository implements UserRepository {
    private Map<Long, User> data = new HashMap<>();
    private AtomicLong idGenerator = new AtomicLong(1L);

    @Override
    public User save(User user) {
        Long id = idGenerator.getAndIncrement();
        data.put(id, user);
        return user;
    }

    @Override
    public Optional<User> findById(Long id) {
        return Optional.ofNullable(data.get(id));
    }
}

// 💡 언제 뭘 쓸까?
// - Stub: 빠른 단위 테스트, 반환값만 필요할 때
// - Mock: 호출 순서/횟수가 중요한 통합 테스트
// - Fake: 여러 테스트에서 재사용할 간단한 구현체
```

테스트 더블은 분명 테스트를 훨씬 **빠르고 편하게** 만들어 준다.
하지만 **너무 많이 쓰면** 오히려 테스트가 불안정해진다.
Mock이 많아질수록 코드 한 줄만 바꿔도 **테스트가 줄줄이 깨지는** 일이 생긴다.
나도 처음엔 대부분의 의존성을 Mock으로 대체했는데, 나중엔 리팩터링할 때마다 **테스트가 발목을 잡았다**.

그래서 지금은 통합 테스트에서는 **Mock을 최소한으로만** 사용하려고 한다.
예를 들어 **외부 API, 결제, 메일 발송**처럼 실제 호출이 부담되는 부분만 Mock으로 처리한다.
그 외에는 가능하면 **실제 객체**를 써서 테스트 흐름을 검증하는 편이 더 믿음직했다.

---

## 마무리

테스트가 없는 환경에서 테스트를 배우고 실무에 적용해 보니,
가장 크게 느낀 건 **'안정감'** 이었다.
예전에는 버그가 날까 봐 코드 수정이 늘 조심스러웠지만,
**테스트 가능한 구조**로 바꾸고 나니 변경에 훨씬 유연해졌고,
코드의 **응집도**도 높아졌으며 **디버깅**도 훨씬 쉬워졌다.

지금은 테스트를 단순히 **코드를 검증하는 도구**로 보지 않는다.
테스트는 **코드를 더 잘 이해하고 구조를 개선**하게 만드는 과정이다.
테스트를 작성하다 보면 **"이 로직의 책임이 어디에 있어야 하지?"** 같은 본질적인 질문을 스스로 던지게 된다. 그 과정이 결국 **더 나은 설계**로 이어졌다.

요즘은 설계의 트레이드오프를 고민할 때,
**"테스트하기 좋은 구조인가?"** 가 나의 중요한 판단 기준이 되었다.

테스트가 아직 낯설고 어렵게 느껴질 수도 있다.
나도 처음엔 **"이걸 왜 해야 하지?"** 에서 시작했다.

하지만 하나씩, **아주 작은 테스트**라도 시작해보자.
작은 테스트 하나라도, 나에게 **코드를 바꿀 용기**를 줬다.

---

## 참고
- 도서: [단위 테스트](https://product.kyobobook.co.kr/detail/S000001805070)
- 강의: [실용적인 테스트 가이드](https://www.inflearn.com/course/practical-testing-실용적인-테스트-가이드)
